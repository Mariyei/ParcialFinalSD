/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stm32l053xx.h"

#define RS 0x01   // PC0
#define RW 0x02   // PC1
#define EN 0x08   // PC3

void delay_ms(uint16_t n);
void LCD_command (unsigned char command);
void LCD_data (char data);
void LCD_init(void);
void PORTS_init(void);
void USART2Init(void);
void USART2_write (uint8_t ch);
uint8_t USART2_read (void);
void USART2_Putstring(uint8_t* stringptr);
void USART2_PutstringE(uint8_t* stringptr);

volatile uint8_t display_index = 0;
#define NUM_4 (0x66)         // 4
#define NUM_1 ( (1<<1) | (1<<2) )                           // 1
#define NUM_5 ( (1<<0) | (1<<2) | (1<<3) | (1<<5) | (1<<6) ) // 5


//Numeros para los displays de 7 segmentos
void display(uint8_t decode) {
    switch (decode) {
        case 0: GPIOB->ODR |= 0x3F; break; // 0
        case 1: GPIOB->ODR |= 0x06; break; // 1
        case 2: GPIOB->ODR |= 0x5B; break; // 2
        case 3: GPIOB->ODR |= 0x4F; break; // 3
        case 4: GPIOB->ODR |= 0x66; break; // 4
        case 5: GPIOB->ODR |= 0x6D; break; // 5
        case 6: GPIOB->ODR |= 0x7D; break; // 6
        case 7: GPIOB->ODR |= 0x07; break; // 7
        case 8: GPIOB->ODR |= 0x7F; break; // 8
        case 9: GPIOB->ODR |= 0x67; break; // 9
        default: break;
    }
}

int main(void)
{

	//ENABLE HSI 16MHZ
		//HSI ON
	RCC->CR |= (1<<0);
		//HSI16 AS SYSCLK
	RCC->CFGR |= (1<<0);


//LCD
	/*LCD_init();

	while (1) {
		LCD_data('H');
		LCD_data ('e');
		LCD_data ('l');
		LCD_data ('l');
		LCD_data ('o');
		delay_ms(200);

		LCD_command(1);
		delay_ms(50);
	}*/

//USART

	PORTS_init();
	USART2Init();
	TIM21config();
	/*while (1) {
		if (USART2_read() == 'k'){
			USART2_PutstringE("Maria A.");
		}
		else if (USART2_read()== 'o'){
			USART2_write('p');
		}

	}*/

//SysTick
	/*
	 Systickconfig ();
	 while(1) {
	 	 if (SysTick->CTRL & 0x1000)
	 	 {
	 	 	 GPIOA->ODR ^=(1<<5);
	 	 }
	 }


	 */

}

void delay_ms(uint16_t n)
{
  uint16_t i;
  for(;n>0;n--)
  	  for(i=0; i<140; i++);
}

void LCD_init (void) {
	PORTS_init();

	delay_ms (30);
	LCD_command(0x30);
	delay_ms(10);
	LCD_command(0x30);
	delay_ms(1);
	LCD_command(0x30);

	LCD_command(0x38);
	LCD_command(0x06);
	LCD_command(0x01);
	LCD_command(0x0F);
}

void PORTS_init (void) {

	RCC->IOPENR |= (1<<0); //Enable clock GPIOA
	RCC->IOPENR |= (1<<1); //Enable clock GPIOB
	RCC->IOPENR |= (1<<2); //Enable clock GPIOC

	GPIOB->MODER &= ~(1<<1); //Config PB0 como output Salida  0
	GPIOB->MODER &= ~(1<<3); //Config PB1 como output Salida  1
	GPIOB->MODER &= ~(1<<5); //Config PB2 como output Salida  2
	GPIOB->MODER &= ~(1<<7); //Config PB3 como output Salida  3
	GPIOB->MODER &= ~(1<<9); //Config PB4 como output Salida  4
	GPIOB->MODER &= ~(1<<11); //Config PB5 como output Salida 5
	GPIOB->MODER &= ~(1<<13); //Config PB6 como output Salida 6
	GPIOB->MODER &= ~(1<<15); //Config PB7 como output (Push 1)
	GPIOB->MODER &= ~(1<<17); //Config PB8 como output (Push 2)
	GPIOB->MODER &= ~(1<<19); //Config PB9 como output (Push 3)
	GPIOB->MODER &= ~(1<<21); //Config PB10 como output (Push 4)
	GPIOB->MODER &= ~(1<<23); //Config PB11 como output (Push 4)
	GPIOB->MODER &= ~(1<<25); //Config PB12 como output (Push 4)





	GPIOC->MODER &= ~(1<<1); // PC0 como salida
	GPIOC->MODER &= ~(1 << 3); // PC1 como salida
	GPIOC->MODER &= ~(1 << 7);  // PC3 como salida
	GPIOC->MODER &= ~(1 << 9);  // PC4 como salida
	GPIOC->MODER &= ~(1 << 11); // PC5 como salida
	GPIOC->MODER &= ~(1 << 13); // PC6 como salida
	GPIOC->MODER &= ~(1 << 15); // PC7 como salida
	GPIOC->MODER &= ~(1 << 17); // PC8 como salida
	GPIOC->MODER &= ~(1 << 19); // PC9 como salida
	GPIOC->MODER &= ~(1 << 21); // PC10 como salida
	GPIOC->MODER &= ~(1 << 23); // PC11 como salida

}

void LCD_command (unsigned  char command) {
	GPIOC->BSRR = (RS |  RW)<<16;
	GPIOC->ODR = (GPIOC->ODR & 0xF00F) | (command << 4);
	GPIOC->BSRR = EN;
	delay_ms(0);
	GPIOC->BSRR = EN<<16;

	if (command < 4)
		delay_ms(2);
	else
		delay_ms(1);

}


void LCD_data (char data) {
	GPIOC->BSRR = RS;
	GPIOC->BSRR = RW <<16;
	GPIOC->ODR = (GPIOC->ODR & 0xF00F) | (data << 4);
	GPIOC->BSRR = EN;
	delay_ms(10);
	GPIOC->BSRR = EN << 16;

	delay_ms(1);

}

void USART2Init(void) {
	//USART CLK ENABLE
	RCC->APB1ENR |= (1<<17);
	//GPIOA CLK ENABLE
	RCC->IOPENR |= (1<<0);
	//ALTERNATE FUNCTION PA2(TX) Y PA3(RX)
	//PA2 as AF
	GPIOA->MODER &= ~(1<<4);
	//PA3 as AF
	GPIOA->MODER &= ~(1<<6);


	//PA2 AS  AF4
	GPIOA->AFR[0] |= (1<<10);
	//PA3 AS AF4
	GPIOA->AFR[0] |= (1<<14);

	//USART2 @115200 bps with 16Mhz clock HSi
	USART2->BRR = 139;
	//USART2 TX ENABLE & RX ENABLE
	USART2->CR1 |= (1<<2)| (1<<3);
	//USART2 MODULE ENABLE
	USART2->CR1 |= (1<<0);

}


void USART2_write (uint8_t ch)
{
	while (!(USART2->ISR & 0X0080)){}
	USART2->TDR = ch;
}

uint8_t USART2_read (void)
{
	while( !(USART2->ISR & 0x0020) ){}
	return USART2->RDR;
}

void USART2_Putstring(uint8_t* stringptr) {
	while(*stringptr != 0x00) {
		USART2_write(*stringptr);
		stringptr++;
	}
}

void USART2_PutstringE(uint8_t* stringptr) {
	while(*stringptr != 0x00) {
		USART2_write(*stringptr);
		stringptr++;
	}
	USART2_write(0x0A);
	USART2_write(0x0D);
}

void Systickconfig (void) {
	//Reload
	SysTick->LOAD = 16000000-1;
	//Se limpia
	SysTick->VAL = 0;
	//Enable Timer with Processor clock as source
	SysTick->CTRL |= (1<<2)|(1<<0);

}

void TIM2config (void) {
	RCC->APB1ENR |= (1<<0);
	TIM2->PSC = 1600-1;
	TIM2->ARR = 10000-1;
	TIM2->CNT = 0;
	TIM2->CR1 = (1<<0);
}

void TIM21config (void) {
	//GPIOB->AFR[1] |=  (1<<21);
	//GPIOB->AFR[1] |=  (1<<22);

	//Se encuentra operando a 1s
	RCC->APB2ENR |= (1<<2);
	TIM21->PSC = 16000-1;
	TIM21->ARR = 2-1;
	TIM21->CNT = 0;
	TIM21->CR1 = (1<<0);

	//Modo Interrupt
	TIM21->DIER |= (1<<0);
	NVIC_EnableIRQ(TIM21_IRQn);
}


void TIM21_IRQHandler() {

	// Apagar todo antes de escribir
	GPIOB->ODR = 0x0000;

    switch (display_index) {
        case 0:
            GPIOB->ODR |= NUM_4 | (1<<7);  // Número 4 en display 1
            break;
        case 1:
            GPIOB->ODR |= NUM_1 | (1<<8);  // Número 1 en display 2
            break;
        case 2:
            GPIOB->ODR |= NUM_4 | (1<<9);  // Número 4 en display 3
            break;
        case 3:
            GPIOB->ODR |= NUM_5 | (1<<10); // Número 5 en display 4
            break;
        case 4:
            GPIOB->ODR |= NUM_5 | (1<<11); // Número 5 en display 5
            break;
        case 5:
            GPIOB->ODR |= NUM_5 | (1<<12); // Número 5 en display 6
            break;
        default:
            display_index = 0; // Reiniciar ciclo
            return;
    }

    display_index++;
    if (display_index > 5) display_index = 0; // Ciclar


	//Clear UIF flag
	TIM21->SR &= ~(1<<0);

}


